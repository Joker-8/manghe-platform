import { persistenceManager } from './utils/database.js';
import sqlite3 from 'sqlite3';
import fs from 'fs';
import path from 'path';

// 测试函数：验证persistenceManager的db属性和execute方法
async function testPersistenceManager() {
    console.log('=== 测试persistenceManager属性 ===');
    console.log('persistenceManager存在:', !!persistenceManager);
    console.log('persistenceManager.db存在:', !!persistenceManager?.db);
    console.log('persistenceManager.db.execute方法存在:', typeof persistenceManager?.db?.execute === 'function');
    
    // 检查auth.js中使用的条件
    const condition = persistenceManager && persistenceManager.db;
    console.log('auth.js条件检查结果:', condition);
    
    // 如果condition为true但不应该为true，这就是漏洞
    if (condition && typeof persistenceManager.db.execute !== 'function') {
        console.log('⚠️  发现安全漏洞: persistenceManager.db存在但没有execute方法！');
    }
}

// 测试函数：模拟auth.js中的登录流程
async function simulateLoginFlow() {
    console.log('\n=== 模拟登录流程测试 ===');
    
    const loginInput = 'nonexistent_user';
    const password = 'anypassword';
    
    // 模拟auth.js中的代码逻辑
    try {
        // 优先使用数据库连接管理器
        if (persistenceManager && persistenceManager.db) {
            console.log('使用persistenceManager连接...');
            
            // 这行代码在实际运行时会失败，但由于JavaScript的特性...
            try {
                const [users] = await persistenceManager.db.execute(
                    'SELECT id, username, email, password FROM users WHERE username = ? OR email = ? LIMIT 1',
                    [loginInput, loginInput]
                );
                console.log('查询结果:', users);
            } catch (executeError) {
                console.log('execute调用错误:', executeError.message);
                // 这里可能有错误处理逻辑导致绕过验证
            }
        } else {
            console.log('persistenceManager不可用，使用备用数据库连接方式');
            
            // 检查SQLite数据库文件
            const dbPath = './data/manghe.db';
            console.log('SQLite数据库文件存在:', fs.existsSync(dbPath));
            
            // 如果数据库不存在，可能会创建一个空数据库
            // 或者返回模拟数据，这可能导致验证绕过
        }
    } catch (error) {
        console.log('登录流程异常:', error.message);
    }
}

// 测试函数：检查SQLite数据库中的用户表
async function checkSqliteDatabase() {
    console.log('\n=== 检查SQLite数据库 ===');
    
    const dbPath = './data/manghe.db';
    
    if (!fs.existsSync(dbPath)) {
        console.log('SQLite数据库文件不存在');
        return;
    }
    
    try {
        const db = new sqlite3.Database(dbPath);
        
        // 检查表是否存在
        db.get("SELECT name FROM sqlite_master WHERE type='table' AND name='users';", (err, row) => {
            if (err) {
                console.log('查询表错误:', err.message);
                db.close();
                return;
            }
            
            console.log('users表存在:', !!row);
            
            // 如果表存在，查询用户数据
            if (row) {
                db.all("SELECT id, username, email FROM users;", (err, rows) => {
                    if (err) {
                        console.log('查询用户数据错误:', err.message);
                    } else {
                        console.log('数据库中的用户数量:', rows.length);
                        console.log('用户列表:', rows);
                    }
                    db.close();
                });
            } else {
                db.close();
            }
        });
    } catch (error) {
        console.log('检查数据库错误:', error.message);
    }
}

// 测试函数：检查数据目录和文件系统存储的用户数据
async function checkFileSystemData() {
    console.log('\n=== 检查文件系统数据 ===');
    
    const dataDir = path.join(process.cwd(), 'data');
    const usersFile = path.join(dataDir, 'users.json');
    
    console.log('数据目录存在:', fs.existsSync(dataDir));
    console.log('users.json文件存在:', fs.existsSync(usersFile));
    
    if (fs.existsSync(usersFile)) {
        try {
            const users = JSON.parse(fs.readFileSync(usersFile, 'utf8'));
            console.log('文件系统中的用户数量:', users.length);
            console.log('用户列表:', users);
        } catch (error) {
            console.log('读取用户文件错误:', error.message);
        }
    }
}

// 测试函数：检查auth.js中可能的漏洞点
function checkAuthVulnerabilities() {
    console.log('\n=== 分析auth.js潜在漏洞 ===');
    
    console.log('可能的漏洞点1: persistenceManager.db可能是一个空对象{}');
    console.log('可能的漏洞点2: try-catch块可能捕获执行错误但仍然允许登录');
    console.log('可能的漏洞点3: 备用数据库连接方式可能存在缺陷');
    console.log('可能的漏洞点4: 错误处理逻辑可能被绕过');
    
    // 模拟persistenceManager.db是一个空对象的情况
    const mockPM = { db: {} };
    const condition1 = mockPM && mockPM.db;
    console.log('模拟空对象条件检查:', condition1);
    
    // 在JavaScript中，即使方法不存在，尝试调用也不会阻止条件检查
}

// 运行所有测试
async function runAllTests() {
    console.log('开始验证登录安全漏洞...\n');
    
    await testPersistenceManager();
    await simulateLoginFlow();
    await checkSqliteDatabase();
    await checkFileSystemData();
    checkAuthVulnerabilities();
    
    console.log('\n=== 漏洞分析完成 ===');
    console.log('如果persistenceManager.db存在但没有正确的execute方法，');
    console.log('这可能导致auth.js中的条件检查通过，但实际执行时出现异常');
    console.log('如果异常处理不当，可能允许未注册用户绕过验证');
}

// 执行测试
runAllTests().catch(console.error);